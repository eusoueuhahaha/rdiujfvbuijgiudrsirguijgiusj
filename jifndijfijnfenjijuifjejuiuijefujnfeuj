local CheckMobile = function()
    if
        game:GetService("UserInputService").TouchEnabled
     then
        return true 
    end
  end 
  IsMobile = CheckMobile()
  local UserInputService = game:GetService("UserInputService")
  local RunService = game:GetService("RunService")
  local Players = game:GetService("Players")
  local LocalPlayer = Players.LocalPlayer
  
  local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
  local GuiService = game:GetService("GuiService")
  
  local screenResolution = GuiService:GetScreenResolution()
  local screenWidth = screenResolution.X
  local screenHeight = screenResolution.Y
  
  local windowWidth = screenWidth * 0.6
  local windowHeight = screenHeight * 0.6
  
  -- UDim2.fromOffset(580, 460),
  if not IsMobile then 
    windowWidth,windowHeight = 600,460  
  else
    local ClickButton = Instance.new("ScreenGui")
    local MainFrame = Instance.new("Frame")
    local ImageLabel = Instance.new("ImageLabel")
    local TextButton = Instance.new("TextButton") 
    local UICorner = Instance.new("UICorner") 
    local UICorner_2 = Instance.new("UICorner")
    if game.CoreGui:FindFirstChild("ClickButton") then 
        game.CoreGui:FindFirstChild("ClickButton"):Destroy()
    end
    ClickButton.Name = "ClickButton"
    ClickButton.Parent = game.CoreGui
    ClickButton.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ClickButton
    MainFrame.Active = true
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Color3.new(1, 1, 1)
    MainFrame.BorderColor3 = Color3.new(0, 0, 0)
    MainFrame.BorderSizePixel = 0
    MainFrame.Transparency = 1
    MainFrame.Position = UDim2.new(0.187441245, 0, 0.476932675, 0)
    MainFrame.Size = UDim2.new(0, 45, 0, 45)
    
    UICorner.CornerRadius = UDim.new(0, 100)
    UICorner.Parent = MainFrame
    
    UICorner_2.CornerRadius = UDim.new(0, 100)
    UICorner_2.Parent = ImageLabel
    
    ImageLabel.Parent = MainFrame
    ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    ImageLabel.BackgroundColor3 = Color3.new(0, 0, 0)
    ImageLabel.BorderColor3 = Color3.new(0, 0, 0)
    ImageLabel.BorderSizePixel = 0
    ImageLabel.Position = UDim2.new(0.48888889, 0, 0.48888889, 0)
    ImageLabel.Size = UDim2.new(0, 45, 0, 45)
    ImageLabel.Image = "rbxassetid://15892713192"
    
    TextButton.Parent = MainFrame
    TextButton.BackgroundColor3 = Color3.new(1, 1, 1)
    TextButton.BackgroundTransparency = 1
    TextButton.BorderColor3 = Color3.new(0, 0, 0)
    TextButton.BorderSizePixel = 0
    TextButton.Position = UDim2.new(3.3908421e-07, 0, 0, 0)
    TextButton.Size = UDim2.new(0, 45, 0, 45)
    TextButton.AutoButtonColor = false
    TextButton.Font = Enum.Font.SourceSans
    TextButton.Text = ""
    TextButton.TextColor3 = Color3.new(255, 255, 255)
    TextButton.TextSize = 15
    TextButton.MouseButton1Click:Connect(function()
        game:GetService("VirtualInputManager"):SendKeyEvent(true,"LeftControl",false,game)
        game:GetService("VirtualInputManager"):SendKeyEvent(false,"LeftControl",false,game)
    end)
  end  
  
  local Window = Fluent:CreateWindow({
    Title = "TsuoHub",
    SubTitle = "developed by mani-",
    TabWidth = 160,
    Size = UDim2.new(0, windowWidth, 0, windowHeight),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
  })
  
  -- Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
  local Tabs = {
    Credits = Window:AddTab({
        Title = "Discord",
        Icon = "gem"
    }),
    AutoFarm = Window:AddTab({
        Title = "AutoFarm",
        Icon = "banknote"
    }),
    MiniGames = Window:AddTab({
        Title = "MiniGames",
        Icon = "gamepad"
    }),
    AutoBuy = Window:AddTab({
        Title = "AutoBuy",
        Icon = "coins"
    }),
    Eggs = Window:AddTab({
        Title = "Eggs",
        Icon = "egg"
    }),
    Teleports = Window:AddTab({
        Title = "Teleports",
        Icon = "aperture"
    }),
    Misc = Window:AddTab({
        Title = "Misc",
        Icon = "settings"
    }),
}
-- credits

Tabs.Credits:AddButton({
    Title = "Tsuo Discord Server (Click 1x)",
    Description = "Copy Link Discord Server",
    Callback = function()
       setclipboard("https://discord.com/invite/tsuoscripts")
    end
})

-- config

getgenv().config = {
    farm = {
        toggle = false,
        singleTarget = false,
        farmPrint = false,
        radius = 70,
        wait = 1
    },
    autoLootbag = false,
    autoOrb = false
}

local LocalPlayer = game.Players.LocalPlayer
local HumanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart", true)

local vim = game:GetService("VirtualInputManager")
local sqrt = math.sqrt
local pow = math.pow

local Things = game.workspace['__THINGS']
local Lootbags = Things.Lootbags
local Orbs = Things.Orbs
local ShinyRelics = Things.ShinyRelics
local Breakables = Things.Breakables
local Pets = Things.Pets
local Network = game:GetService("ReplicatedStorage").Network
local PetInventory = LocalPlayer.PlayerGui.Inventory.Frame.Main.Pets.EquippedPets

getgenv().currentCoins = {}
getgenv().equippedPets = {}
getgenv().totalClaimed = 0
getgenv().totalTime = 0

local function indexPets()
    table.clear(equippedPets)
    for _, pet in ipairs(Pets:GetChildren()) do
        if PetInventory:FindFirstChild(pet.Name) then
            table.insert(equippedPets, pet.Name)
        end
    end
    return equippedPets
end
local function calcDistance(obj1, obj2)
    local pPosX, pPosZ = obj1.CFrame.X, obj1.CFrame.Z
    local hPosX, hPosZ = obj2.CFrame.X, obj2.CFrame.Z

    return sqrt(pow(pPosX - hPosX, 2) + pow(pPosZ - hPosZ, 2))
end
local function getCenter()
    local frame = Instance.new("Frame")
    frame.Parent = game.CoreGui
    frame.Name = LocalPlayer.Name
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.Position = UDim2.fromScale(0.5, 0.5)
    frame.Size = UDim2.fromOffset(10, 10)
    frame.Visible = false

    return { frame.AbsolutePosition.X, frame.AbsolutePosition.Y }
end


local isFeatureEnabled = false -- Set the initial state of the feature
local loopHandle               -- Variable to hold the loop handle

local function toggleFeature(value)
    isFeatureEnabled = value -- Update the state of the feature
    if isFeatureEnabled then
        --[[ WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk! ]]
        local a = game.Players.LocalPlayer.Character.HumanoidRootPart
        local b = workspace.__THINGS

        local function get()
            local cf = a.CFrame
            for i, v in pairs(b.Orbs:GetChildren()) do
                v:PivotTo(cf)
            end
        end

        loopHandle = game:GetService("RunService").Heartbeat:Connect(function()
            if isFeatureEnabled then
                get()
            end
        end)
    else
        if loopHandle then
            loopHandle:Disconnect() -- Stop the loop if the feature is disabled
            loopHandle = nil
        end
    end
end

do

local Coin = Tabs.AutoFarm:AddToggle("Coin", {Title = "Farm-Coin", Default = false })

Coin:OnChanged(function(value)
    config.farm.toggle = value
        while config.farm.toggle and task.wait() do
            for _, v in ipairs(Breakables:GetChildren()) do
                if v.Name ~= "Highlight" and v:FindFirstChild("Hitbox", true) then
                    local part = v:FindFirstChild("Hitbox", true)

                    if calcDistance(part, HumanoidRootPart) <= config.farm.radius then
                        if config.farm.singleTarget then
                            local tmpName = v.Name
                            local startTime = os.clock()

                            repeat
                                if calcDistance(part, HumanoidRootPart) > config.farm.radius then
                                    break
                                end
                                task.wait(config.farm.wait)
                                Network.Breakables_PlayerDealDamage:FireServer(v.Name)
                            until not Breakables:FindFirstChild(v.Name)

                            totalClaimed = totalClaimed + 1; totalTime = totalTime + (os.clock() - startTime)
                            if config.farm.farmPrint then print("farmed " ..
                                tmpName ..
                                " in: " .. tostring(os.clock() - startTime) .. " Avg: " ..
                                tostring(totalTime / totalClaimed)) end
                        else
                            if not table.find(currentCoins, v.Name) then
                                table.insert(currentCoins, v.Name)
                                task.spawn(function()
                                    local tmpPart = part
                                    local tmpName = v.Name
                                    local startTime = os.clock()
                                    repeat
                                        if calcDistance(tmpPart, HumanoidRootPart) > config.farm.radius then
                                            table.remove(currentCoins, table.find(currentCoins, v.Name))
                                            break
                                        end

                                        task.wait(config.farm.wait * math.random(1, 2))

                                        Network.Breakables_PlayerDealDamage:FireServer(tmpName)
                                    until not Breakables:FindFirstChild(tmpName)

                                    table.remove(currentCoins, table.find(currentCoins, v.Name))
                                    totalClaimed = totalClaimed + 1; totalTime = totalTime + (os.clock() - startTime)
                                    if config.farm.farmPrint then print("farmed " ..
                                        tmpName ..
                                        " in: " ..
                                        tostring(os.clock() - startTime) .. " Avg: " .. tostring(totalTime / totalClaimed)) end
                                end)
                            end
                        end
                    end
                end
            end
        end
    end)
end

local Radius = Tabs.AutoFarm:AddSlider("Radius", {
    Title = "Radius",
    Description = "",
    Default = 70,
    Min = 70,
    Max = 200,
    Rounding = 1,
    Callback = function(value)
        if tonumber(value) then
            config.farm.radius = tonumber(value)
        else
            config.farm.radius = 70
        end
    end
})

local Wait = Tabs.AutoFarm:AddSlider("Wait", {
    Title = "Wait-Time",
    Description = "",
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Callback = function(value)
        if tonumber(value) then
            config.farm.wait = tonumber(value)
        else
            config.farm.wait = 1
        end
    end
})

local function startAutoFishing()
    local plr = game.Players.LocalPlayer
    local ws = game:GetService("Workspace")
    local rStorage = game:GetService("ReplicatedStorage")
    local remote = rStorage.Network.Instancing_FireCustomFromClient

    local fishingGame = plr.PlayerGui._INSTANCES.FishingGame
    local fishingBar = fishingGame.GameBar.FishingBar
    local fishingRod = ws:WaitForChild(tostring(plr)).Model.Rod

    local args = {
        "Fishing",
        "RequestCast",
        Vector3.new(1139.0439453125, 75.91415405273438, -3445.31982421875)
    }

    -- Function to check if the fish is in the bar
    require(game:GetService("Workspace").__THINGS.__INSTANCE_CONTAINER.Active.Fishing.ClientModule.FishingGame).IsFishInBar = function()
        return true
    end

    while wait(0.3) do
        if not getgenv().autoFish then
            break
        end

        if not fishingRod:FindFirstChild("FishingLine") then
            remote:FireServer(unpack(args))
            wait(0.5)
        end

        if fishingRod:FindFirstChild("FishingLine") then
            while fishingRod:FindFirstChild("FishingLine") and getgenv().autoFish do
                local attachment1 = fishingRod.FishingLine.Attachment1
                local bobber = attachment1.Parent
                local height = bobber.CFrame.Position.Y

                if height > 75.91415405273438 then
                    print("Too high, waiting")
                elseif height == 75.91415405273438 then
                    print("No fish, waiting")
                elseif height < 75.8 then
                    print("Fish detected, reeling")
                    remote:FireServer("Fishing", "RequestReel")
                end

                wait(0.3)
            end
        end
    end
end

local Fishing = Tabs.MiniGames:AddToggle("Fishing", {Title = "Auto-Fishing", Default = false })

Fishing:OnChanged(function(Value)
    getgenv().autoFish = Value

    if Value then
        startAutoFishing()
    end
end)

local toggleState = false
local hatchingProcess = nil
local EGGVALUE = "Cracked Egg" -- Set a default value
local HATCHAMMOUNT = 1         -- Default hatching amount

local function startHatching()
    while toggleState do
        local args = {
            [1] = EGGVALUE,
            [2] = HATCHAMMOUNT
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Eggs_RequestPurchase"):InvokeServer(
        unpack(args))
        wait(0.3) -- Adjust the time interval between hatching attempts
    end
end

local Eggs = Tabs.Eggs:AddDropdown("Eggs", {
    Title = "Select-Egg",
    Values = {
        "None",
        "Cracked Egg",
        "Spotted Egg",
        "Paw Egg",
        "Grass Egg",
        "Wood Egg",
        "Pumpkin Egg",
        "Hive Egg",
        "Acorn Egg",
        "Blossom Egg",
        "Corgi Egg",
        "Cat Egg",
        "Dog Egg",
        "Dragon Egg",
        "Rock Egg",
        "Geode Egg",
        "Hut Egg",
        "Grave Egg",
        "Spike Egg",
        "Sprout Egg",
        "Mushroom Egg",
        "Spirit Egg",
        "Crimson Egg",
        "Overgrown Egg",
        "Mossy Egg",
        "Jungle Egg",
        "Sandcastle Egg",
        "Palm Tree Egg",
        "Beach Ball Egg",
        "Coral Egg",
        "Anchor Egg",
        "Atlantis Egg",
        "Tropical Egg",
        "Beach Egg",
        "Coconut Egg",
        "Tiki Egg",
        "Sand Bucket Egg",
        "Sunny Egg",
        "Pirate Egg",
        "Ship Egg",
        "Zebra Egg",
        "Cheetah Egg",
        "Cactus Egg",
        "Fossil Egg",
        "Egyptian Egg",
        "Sandstone Egg",
        "Cowboy Egg",
        "Canyon Egg",
        "Hyena Egg",
        "Melted Egg",
        "Snow Egg",
        "Icicle Egg",
        "Snowman Egg",
        "Yeti Egg",
        "Ice Egg",
        "Thawed Egg",
        "Magma Egg",
        "Obsidian Egg",
        "Volcano Egg",
        "Bone Egg",
        "Tentacle Egg",
        "Hell Egg",
        "Metal Egg",
        "Sakura Egg",
        "Ninja Egg",
        "Lantern Egg",
        "Bonsai Egg",
        "Garden Egg",
        "Pixie Egg",
        "Pedal Egg",
        "Crowned Egg",
        "Royal Egg",
        "Dandelion Egg",
        "Colorful Egg",
        "Colorful Geode Egg",
        "Colorful Mosaic Egg",
        "Frosted Geode Egg",
        "Sculpture Egg",
        "Cocoa Egg",
        "Castle Egg Egg",
        "Teddy Egg"  
    },
    Multi = false,
    Default = "None",
})

Eggs:OnChanged(function(value)
    EGGVALUE = value
    print(EGGVALUE)
end)

local Hatching = Tabs.Eggs:AddSlider("Hatching", {
    Title = "Hatching-Ammount",
    Description = "",
    Default = HATCHAMMOUNT,
    Min = 1,
    Max = 75,
    Rounding = 1,
    Callback = function(value)
        HATCHAMMOUNT = value
        print(HATCHAMMOUNT)
    end
})

local AutoBuy = Tabs.Eggs:AddToggle("AutoBuy", {Title = "Auto-Buy-Eggs", Default = false })

AutoBuy:OnChanged(function(value)
    toggleState = value

    if toggleState then
        -- Start the hatching process when toggle is turned on
        hatchingProcess = coroutine.create(startHatching)
        coroutine.resume(hatchingProcess)
    else
        -- Stop the hatching process when toggle is turned off
        if hatchingProcess then
            coroutine.yield(hatchingProcess)
            hatchingProcess = nil
        end
    end
end)

local toggleState = false
local originalPlayEggAnimation = nil

local Hatch = Tabs.Eggs:AddToggle("Hatch", {Title = "Remove-Hatch-Animations", Default = false })

Hatch:OnChanged(function(Value)
    toggleState = Value -- Update the toggle state

        local Eggs = game.Players.LocalPlayer.PlayerScripts.Scripts.Game['Egg Opening Frontend']
        if toggleState then
            -- Store the original function and redefine it to do nothing
            originalPlayEggAnimation = getsenv(Eggs).PlayEggAnimation
            getsenv(Eggs).PlayEggAnimation = function() return end
        else
            -- Restore the original function
            if originalPlayEggAnimation then
                getsenv(Eggs).PlayEggAnimation = originalPlayEggAnimation
            end
        end
    end)

    Tabs.AutoBuy:AddButton({
        Title = "Claim-Free-Lootbags",
        Description = "",
        Callback = function()
            for i = 1, 12 do
                local args = {
                    [1] = i
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Network"):WaitForChild("Redeem Free Gift"):InvokeServer(
                unpack(args))
            end
        end
    })

    Tabs.AutoBuy:AddButton({
        Title = "Claim-Free-Rewards",
        Description = "",
        Callback = function()
            local remotes = game.ReplicatedStorage.Network
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid

        local DailyRedeemables = {
            { "Castle",     "SmallDailyDiamonds" },
            { "Jungle",     "DailyPotions" },
            { "Red Desert", "MediumDailyDiamonds" },
        }

        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(DailyRedeemables) do
            teleport(v[1])
            daily_redeem:InvokeServer(v[2])
        end
    end
})

Tabs.AutoBuy:AddButton({
    Title = "Auto-Buy-Merchant-Shop",
    Description = "",
    Callback = function()
        local remotes = game.ReplicatedStorage.Network
        local teleportr = remotes.Teleports_RequestTeleport
        local vending_buy = remotes.VendingMachines_Purchase
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid
        local merchant_buy = remotes.Merchant_RequestPurchase

        local Merchants = {
            { "RegularMerchant",  "Oasis" },
            { "AdvancedMerchant", "Ice Rink" },
            { "GardenMerchant",   "Flower Field" }
        }

        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(Merchants) do
            teleport(v[2])
            task.wait(1)
            local a, b
            for i = 1, 6, 1 do
                repeat
                    a, b = merchant_buy:InvokeServer(v[1], i)
                    task.wait(0.3)
                until a == false
            end
        end
    end
})

Tabs.AutoBuy:AddButton({
    Title = "Auto-Buy-All",
    Description = "",
    Callback = function()
        -- auto merchange vending machine

        local remotes = game.ReplicatedStorage.Network
        local teleportr = remotes.Teleports_RequestTeleport
        local vending_buy = remotes.VendingMachines_Purchase
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid
        local merchant_buy = remotes.Merchant_RequestPurchase

        local machines = {
            { "PotionVendingMachine1",       "Cherry Blossom" },
            { "PotionVendingMachine2",       "Safari" },
            { "EnchantVendingMachine1",      "Misty Falls" },
            { "EnchantVendingMachine2",      "Fire and Ice" },
            { "RareEnchantsVendingMachine1", "Samurai Village" },
            { "FruitVendingMachine1",        "Mushroom Field" },
            { "FruitVendingMachine2",        "Pirate Cove" },
        }


        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(machines) do
            teleport(v[2])
            local a, b
            for i2, v2 in pairs(workspace.Map:GetChildren()) do
                if string.find(v2.Name, v[2], 1, true) then
                    hum.Parent:PivotTo(v2.INTERACT.Machines[v[1]].PrimaryPart.CFrame * CFrame.new(0, 9, 0))
                end
            end

            repeat
                a, b = vending_buy:InvokeServer(v[1], 1)
                task.wait(0.3)
            until a == false
        end

        for i, v in ipairs(DailyRedeemables) do
            teleport(v[1])
            daily_redeem:InvokeServer(v[2])
        end

        for i, v in ipairs(Merchants) do
            teleport(v[2])
            task.wait(1)
            local a, b
            for i = 1, 6, 1 do
                repeat
                    a, b = merchant_buy:InvokeServer(v[1], i)
                    task.wait(0.3)
                until a == false
            end
        end
    end
})

Tabs.AutoBuy:AddButton({
    Title = "Auto-Buy-Fruits-Vending-Machine",
    Description = "",
    Callback = function()
        -- auto merchandise vending machine

        local remotes = game.ReplicatedStorage.Network
        local teleportr = remotes.Teleports_RequestTeleport
        local vending_buy = remotes.VendingMachines_Purchase
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid
        local merchant_buy = remotes.Merchant_RequestPurchase

        local machines = {
            { "FruitVendingMachine1", "Mushroom Field" },
            { "FruitVendingMachine2", "Pirate Cove" },
        }

        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(machines) do
            teleport(v[2])
            local a, b
            for i2, v2 in pairs(workspace.Map:GetChildren()) do
                if string.find(v2.Name, v[2], 1, true) then
                    hum.Parent:PivotTo(v2.INTERACT.Machines[v[1]].PrimaryPart.CFrame * CFrame.new(0, 9, 0))
                end
            end

            repeat
                a, b = vending_buy:InvokeServer(v[1], 1)
                task.wait(0.3)
            until a == false
        end
    end
})

Tabs.AutoBuy:AddButton({
    Title = "Auto-Buy-Potion-Vending-Machine",
    Description = "",
    Callback = function()
        -- auto merchange vending machine

        local remotes = game.ReplicatedStorage.Network
        local teleportr = remotes.Teleports_RequestTeleport
        local vending_buy = remotes.VendingMachines_Purchase
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid
        local merchant_buy = remotes.Merchant_RequestPurchase

        local machines = {
            { "PotionVendingMachine1", "Cherry Blossom" },
            { "PotionVendingMachine2", "Safari" },
        }

        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(machines) do
            teleport(v[2])
            local a, b
            for i2, v2 in pairs(workspace.Map:GetChildren()) do
                if string.find(v2.Name, v[2], 1, true) then
                    hum.Parent:PivotTo(v2.INTERACT.Machines[v[1]].PrimaryPart.CFrame * CFrame.new(0, 9, 0))
                end
            end

            repeat
                a, b = vending_buy:InvokeServer(v[1], 1)
                task.wait(0.3)
            until a == false
        end
    end
})

Tabs.AutoBuy:AddButton({
    Title = "Auto-Buy-Enchant-Vending-Machine",
    Description = "",
    Callback = function()
        -- auto merchange vending machine

        local remotes = game.ReplicatedStorage.Network
        local teleportr = remotes.Teleports_RequestTeleport
        local vending_buy = remotes.VendingMachines_Purchase
        local daily_redeem = remotes.DailyRewards_Redeem
        local hum = game.Players.LocalPlayer.Character.Humanoid
        local merchant_buy = remotes.Merchant_RequestPurchase

        local machines = {
            { "EnchantVendingMachine1",      "Misty Falls" },
            { "EnchantVendingMachine2",      "Fire and Ice" },
            { "RareEnchantsVendingMachine1", "Samurai Village" },
        }

        local function teleport(destination)
            teleportr:InvokeServer(destination)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Air
            task.wait(0.5)
            repeat task.wait() until hum.FloorMaterial == Enum.Material.Plastic
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait(1)
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        for i, v in ipairs(machines) do
            teleport(v[2])
            local a, b
            for i2, v2 in pairs(workspace.Map:GetChildren()) do
                if string.find(v2.Name, v[2], 1, true) then
                    hum.Parent:PivotTo(v2.INTERACT.Machines[v[1]].PrimaryPart.CFrame * CFrame.new(0, 9, 0))
                end
            end

            repeat
                a, b = vending_buy:InvokeServer(v[1], 1)
                task.wait(0.3)
            until a == false
        end
    end
})

Tabs.Teleports:AddButton({
    Title = "Teleport-To-Hidden-Gifts",
    Description = "",
    Callback = function()
        _G.stopTeleporting = false 

        local function findClosestChild(children, player)
            if not children or #children == 0 then
                return
            end

            local closestChild = nil
            local shortestDistance = math.huge

            for _, v in ipairs(children) do
                if v.Name == "Highlight" or v.Transparency == 0.75 then
                    continue
                end

                local distance = (v.Position - player.Character.HumanoidRootPart.Position).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestChild = v
                end
            end

            return closestChild
        end

        local children = game:GetService("Workspace")["__THINGS"].Presents:GetChildren()
        local player = game.Players.LocalPlayer
        local lastTeleportedChild = nil

        while not _G.stopTeleporting do
            local closestChild = findClosestChild(children, player)
            if not closestChild then
                print("No closest child found.")
                break
            end

            if lastTeleportedChild == closestChild then
                print("Already teleported to this child.")
                continue
            end

            lastTeleportedChild = closestChild
            local startTime = os.time()
            while os.difftime(os.time(), startTime) < 5 do
                if not player.Character or not player.Character.HumanoidRootPart then
                    print("Player or HumanoidRootPart not found.")
                    break
                end
                player.Character.HumanoidRootPart.CFrame = CFrame.new(closestChild.Position)
                task.wait()
            end

            local childFound = false
            for i, child in ipairs(children) do
                if child == closestChild then
                    table.remove(children, i)
                    childFound = true
                    break
                end
            end
            if not childFound then
                print("Child not found in the list.")
            end
        end
    end
})

local Rendering = Tabs.Misc:AddToggle("Rendering", {Title = "3D Rendering", Default = false })

Rendering:OnChanged(function(Value)
    ToggleEnabled = Value
    game:GetService("RunService"):Set3dRenderingEnabled(not ToggleEnabled)
end)

Tabs.Misc:AddButton({
    Title = "Rejoin",
    Description = "",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, game:GetService("Players").LocalPlayer)
    end
})

Tabs.Misc:AddButton({
    Title = "Server-Hop",
    Description = "",
    Callback = function()
        local Player = game.Players.LocalPlayer
        local Http = game:GetService("HttpService")
        local TPS = game:GetService("TeleportService")
        local Api = "https://games.roblox.com/v1/games/"

        local _place, _id = game.PlaceId, game.JobId
        local _servers = Api .. _place .. "/servers/Public?sortOrder=Desc&limit=100"
        function ListServers(cursor)
            local Raw = game:HttpGet(_servers .. ((cursor and "&cursor=" .. cursor) or ""))
            return Http:JSONDecode(Raw)
        end

        local Next; repeat
            local Servers = ListServers(Next)
            for i, v in next, Servers.data do
                if v.playing < v.maxPlayers and v.id ~= _id then
                    local s, r = pcall(TPS.TeleportToPlaceInstance, TPS, _place, v.id, Player)
                    if s then break end
                end
            end

            Next = Servers.nextPageCursor
        until not Next
    end
})

Tabs.Misc:AddButton({
    Title = "Anti-AFK",
    Description = "",
    Callback = function()
        local VU = game:GetService("VirtualUser")

        game:GetService("Players").LocalPlayer.Idled:connect(function()
            VU:CaptureController()
            VU:ClickButton2(Vector2.new())
            print("Skipped")
        end)
        print("Anti Afk Enabled.")
    end
})
